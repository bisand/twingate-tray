package main

import (
	"math"
)

// Font Awesome lock icon polygon data (normalized [0,1] coordinates).
// Derived from Font Awesome Free 6.7.2 (CC BY 4.0).
// viewBox: 0 0 448 512
// Uses even-odd fill rule. Polygon 0 is the shackle hole (subtracted).

var faLockPolygons = [][][2]float64{
	// Polygon 0: shackle inner cutout (37 points)
	{
		{0.321429, 0.281250},
		{0.321429, 0.375000},
		{0.678571, 0.375000},
		{0.678571, 0.281250},
		{0.677650, 0.265269},
		{0.674945, 0.249751},
		{0.670547, 0.234774},
		{0.664544, 0.220416},
		{0.657027, 0.206757},
		{0.648084, 0.193874},
		{0.637807, 0.181847},
		{0.626283, 0.170752},
		{0.613604, 0.160669},
		{0.599858, 0.151676},
		{0.585135, 0.143852},
		{0.569524, 0.137274},
		{0.553116, 0.132022},
		{0.535999, 0.128173},
		{0.518264, 0.125806},
		{0.500000, 0.125000},
		{0.481736, 0.125806},
		{0.464001, 0.128173},
		{0.446884, 0.132022},
		{0.430476, 0.137274},
		{0.414865, 0.143852},
		{0.400142, 0.151676},
		{0.386396, 0.160669},
		{0.373717, 0.170752},
		{0.362193, 0.181847},
		{0.351916, 0.193874},
		{0.342973, 0.206757},
		{0.335456, 0.220416},
		{0.329453, 0.234774},
		{0.325055, 0.249751},
		{0.322350, 0.265269},
		{0.321429, 0.281250},
		{0.321429, 0.281250},
	},
	// Polygon 1: outer shape (105 points)
	{
		{0.178571, 0.375000},
		{0.178571, 0.281250},
		{0.180232, 0.252503},
		{0.185104, 0.224585},
		{0.193028, 0.197636},
		{0.203840, 0.171799},
		{0.217379, 0.147215},
		{0.233483, 0.124025},
		{0.251991, 0.102372},
		{0.272740, 0.082397},
		{0.295568, 0.064242},
		{0.320315, 0.048048},
		{0.346817, 0.033957},
		{0.374913, 0.022110},
		{0.404441, 0.012649},
		{0.435240, 0.005716},
		{0.467146, 0.001453},
		{0.500000, 0.000000},
		{0.532854, 0.001453},
		{0.564760, 0.005716},
		{0.595559, 0.012649},
		{0.625087, 0.022110},
		{0.653183, 0.033957},
		{0.679685, 0.048048},
		{0.704432, 0.064242},
		{0.727260, 0.082397},
		{0.748009, 0.102372},
		{0.766517, 0.124025},
		{0.782621, 0.147215},
		{0.796160, 0.171799},
		{0.806972, 0.197636},
		{0.814896, 0.224585},
		{0.819768, 0.252503},
		{0.821429, 0.281250},
		{0.821429, 0.375000},
		{0.857143, 0.375000},
		{0.871732, 0.375646},
		{0.885904, 0.377543},
		{0.899586, 0.380627},
		{0.912706, 0.384836},
		{0.925191, 0.390105},
		{0.936970, 0.396372},
		{0.947970, 0.403573},
		{0.958119, 0.411646},
		{0.967345, 0.420526},
		{0.975575, 0.430151},
		{0.982737, 0.440458},
		{0.988759, 0.451382},
		{0.993569, 0.462862},
		{0.997093, 0.474834},
		{0.999261, 0.487234},
		{1.000000, 0.500000},
		{1.000000, 0.875000},
		{0.999261, 0.887766},
		{0.997093, 0.900166},
		{0.993569, 0.912138},
		{0.988759, 0.923618},
		{0.982737, 0.934542},
		{0.975575, 0.944849},
		{0.967345, 0.954474},
		{0.958119, 0.963354},
		{0.947970, 0.971427},
		{0.936970, 0.978628},
		{0.925191, 0.984895},
		{0.912706, 0.990164},
		{0.899586, 0.994373},
		{0.885904, 0.997457},
		{0.871732, 0.999354},
		{0.857143, 1.000000},
		{0.142857, 1.000000},
		{0.128268, 0.999354},
		{0.114096, 0.997457},
		{0.100414, 0.994373},
		{0.087294, 0.990164},
		{0.074809, 0.984895},
		{0.063030, 0.978628},
		{0.052030, 0.971427},
		{0.041881, 0.963354},
		{0.032655, 0.954474},
		{0.024425, 0.944849},
		{0.017263, 0.934542},
		{0.011241, 0.923618},
		{0.006431, 0.912138},
		{0.002907, 0.900166},
		{0.000739, 0.887766},
		{0.000000, 0.875000},
		{0.000000, 0.500000},
		{0.000739, 0.487234},
		{0.002907, 0.474834},
		{0.006431, 0.462862},
		{0.011241, 0.451382},
		{0.017263, 0.440458},
		{0.024425, 0.430151},
		{0.032655, 0.420526},
		{0.041881, 0.411646},
		{0.052030, 0.403573},
		{0.063030, 0.396372},
		{0.074809, 0.390105},
		{0.087294, 0.384836},
		{0.100414, 0.380627},
		{0.114096, 0.377543},
		{0.128268, 0.375646},
		{0.142857, 0.375000},
		{0.178571, 0.375000},
		{0.178571, 0.375000},
	},
}

// Font Awesome unlock icon polygon data (normalized [0,1] coordinates).
// Derived from Font Awesome Free 6.7.2 (CC BY 4.0).
// viewBox: 0 0 448 512

var faUnlockPolygons = [][][2]float64{
	// Polygon 0: single outline (169 points)
	{
		{0.321429, 0.281250},
		{0.322350, 0.265269},
		{0.325055, 0.249751},
		{0.329453, 0.234774},
		{0.335456, 0.220416},
		{0.342973, 0.206757},
		{0.351916, 0.193874},
		{0.362193, 0.181847},
		{0.373717, 0.170752},
		{0.386396, 0.160669},
		{0.400142, 0.151676},
		{0.414865, 0.143852},
		{0.430476, 0.137274},
		{0.446884, 0.132022},
		{0.464001, 0.128173},
		{0.481736, 0.125806},
		{0.500000, 0.125000},
		{0.513230, 0.125421},
		{0.526197, 0.126664},
		{0.538867, 0.128701},
		{0.551207, 0.131503},
		{0.563183, 0.135041},
		{0.574762, 0.139286},
		{0.585911, 0.144208},
		{0.596596, 0.149780},
		{0.606784, 0.155972},
		{0.616442, 0.162756},
		{0.625536, 0.170102},
		{0.634033, 0.177982},
		{0.641900, 0.186366},
		{0.649103, 0.195226},
		{0.655609, 0.204533},
		{0.661384, 0.214258},
		{0.664858, 0.219904},
		{0.668885, 0.225114},
		{0.673417, 0.229874},
		{0.678408, 0.234167},
		{0.683807, 0.237980},
		{0.689568, 0.241298},
		{0.695642, 0.244105},
		{0.701981, 0.246387},
		{0.708537, 0.248128},
		{0.715263, 0.249315},
		{0.722109, 0.249932},
		{0.729028, 0.249963},
		{0.735972, 0.249396},
		{0.742893, 0.248213},
		{0.749743, 0.246401},
		{0.756473, 0.243945},
		{0.762889, 0.240906},
		{0.768817, 0.237382},
		{0.774237, 0.233416},
		{0.779133, 0.229050},
		{0.783486, 0.224325},
		{0.787278, 0.219284},
		{0.790492, 0.213970},
		{0.793108, 0.208423},
		{0.795110, 0.202686},
		{0.796480, 0.196801},
		{0.797198, 0.190811},
		{0.797248, 0.184756},
		{0.796612, 0.178680},
		{0.795270, 0.172625},
		{0.793206, 0.166631},
		{0.790402, 0.160742},
		{0.780053, 0.143294},
		{0.768384, 0.126582},
		{0.755453, 0.110660},
		{0.741323, 0.095581},
		{0.726051, 0.081399},
		{0.709699, 0.068169},
		{0.692327, 0.055943},
		{0.673996, 0.044775},
		{0.654764, 0.034720},
		{0.634692, 0.025832},
		{0.613841, 0.018163},
		{0.592271, 0.011768},
		{0.570042, 0.006700},
		{0.547213, 0.003014},
		{0.523846, 0.000762},
		{0.500000, 0.000000},
		{0.467146, 0.001453},
		{0.435240, 0.005716},
		{0.404441, 0.012649},
		{0.374913, 0.022110},
		{0.346817, 0.033957},
		{0.320315, 0.048048},
		{0.295568, 0.064242},
		{0.272740, 0.082397},
		{0.251991, 0.102372},
		{0.233483, 0.124025},
		{0.217379, 0.147215},
		{0.203840, 0.171799},
		{0.193028, 0.197636},
		{0.185104, 0.224585},
		{0.180232, 0.252503},
		{0.178571, 0.281250},
		{0.178571, 0.375000},
		{0.142857, 0.375000},
		{0.128268, 0.375646},
		{0.114096, 0.377543},
		{0.100414, 0.380627},
		{0.087294, 0.384836},
		{0.074809, 0.390105},
		{0.063030, 0.396372},
		{0.052030, 0.403573},
		{0.041881, 0.411646},
		{0.032655, 0.420526},
		{0.024425, 0.430151},
		{0.017263, 0.440458},
		{0.011241, 0.451382},
		{0.006431, 0.462862},
		{0.002907, 0.474834},
		{0.000739, 0.487234},
		{0.000000, 0.500000},
		{0.000000, 0.875000},
		{0.000739, 0.887766},
		{0.002907, 0.900166},
		{0.006431, 0.912138},
		{0.011241, 0.923618},
		{0.017263, 0.934542},
		{0.024425, 0.944849},
		{0.032655, 0.954474},
		{0.041881, 0.963354},
		{0.052030, 0.971427},
		{0.063030, 0.978628},
		{0.074809, 0.984895},
		{0.087294, 0.990164},
		{0.100414, 0.994373},
		{0.114096, 0.997457},
		{0.128268, 0.999354},
		{0.142857, 1.000000},
		{0.857143, 1.000000},
		{0.871732, 0.999354},
		{0.885904, 0.997457},
		{0.899586, 0.994373},
		{0.912706, 0.990164},
		{0.925191, 0.984895},
		{0.936970, 0.978628},
		{0.947970, 0.971427},
		{0.958119, 0.963354},
		{0.967345, 0.954474},
		{0.975575, 0.944849},
		{0.982737, 0.934542},
		{0.988759, 0.923618},
		{0.993569, 0.912138},
		{0.997093, 0.900166},
		{0.999261, 0.887766},
		{1.000000, 0.875000},
		{1.000000, 0.500000},
		{0.999261, 0.487234},
		{0.997093, 0.474834},
		{0.993569, 0.462862},
		{0.988759, 0.451382},
		{0.982737, 0.440458},
		{0.975575, 0.430151},
		{0.967345, 0.420526},
		{0.958119, 0.411646},
		{0.947970, 0.403573},
		{0.936970, 0.396372},
		{0.925191, 0.390105},
		{0.912706, 0.384836},
		{0.899586, 0.380627},
		{0.885904, 0.377543},
		{0.871732, 0.375646},
		{0.857143, 0.375000},
		{0.321429, 0.375000},
		{0.321429, 0.281250},
		{0.321429, 0.281250},
	},
}

// generateIconARGB creates a Font Awesome lock/unlock icon as raw ARGB pixel data
// in network byte order (big-endian). Size is 256x256.
// Connected: white closed lock (fa:lock)
// Disconnected: gray open lock (fa:unlock)
func generateIconARGB(connected bool) ([]byte, int32, int32) {
	const size = 256
	data := make([]byte, size*size*4)

	var polygons [][][2]float64
	var r, g, b uint8

	if connected {
		polygons = faLockPolygons
		r, g, b = 255, 255, 255 // White
	} else {
		polygons = faUnlockPolygons
		r, g, b = 140, 140, 140 // Gray
	}

	// Scale polygons from normalized [0,1] to pixel coordinates.
	// The FA lock viewBox is 448x512 (not square). We need to fit it centered
	// in a 256x256 square with some padding.
	padding := float64(size) * 0.08
	available := float64(size) - 2*padding

	// FA lock viewBox aspect ratio: 448/512 = 0.875 (taller than wide)
	// FA unlock viewBox: same 448/512
	vbAspect := 448.0 / 512.0
	var scaleW, scaleH, offsetX, offsetY float64

	if vbAspect < 1.0 {
		// Taller than wide: fit to height, center horizontally
		scaleH = available
		scaleW = available * vbAspect
		offsetX = padding + (available-scaleW)/2
		offsetY = padding
	} else {
		// Wider than tall: fit to width, center vertically
		scaleW = available
		scaleH = available / vbAspect
		offsetX = padding
		offsetY = padding + (available-scaleH)/2
	}

	// For each pixel, count polygon edge crossings (even-odd fill rule)
	for y := 0; y < size; y++ {
		fy := float64(y) + 0.5 // Sample at pixel center

		for x := 0; x < size; x++ {
			fx := float64(x) + 0.5 // Sample at pixel center

			crossings := 0
			for _, poly := range polygons {
				crossings += countCrossings(poly, fx, fy, scaleW, scaleH, offsetX, offsetY)
			}

			if crossings%2 == 1 {
				idx := (y*size + x) * 4
				data[idx] = 255 // A
				data[idx+1] = r
				data[idx+2] = g
				data[idx+3] = b
			}
		}
	}

	return data, int32(size), int32(size)
}

// countCrossings counts how many times a ray from (px, py) going right
// crosses the edges of the given polygon. Polygon coordinates are normalized
// [0,1] and scaled by the given parameters.
func countCrossings(poly [][2]float64, px, py, scaleW, scaleH, offsetX, offsetY float64) int {
	n := len(poly)
	if n < 3 {
		return 0
	}

	crossings := 0
	for i := 0; i < n; i++ {
		j := (i + 1) % n

		// Scale polygon points to pixel coordinates
		y1 := poly[i][1]*scaleH + offsetY
		y2 := poly[j][1]*scaleH + offsetY
		x1 := poly[i][0]*scaleW + offsetX
		x2 := poly[j][0]*scaleW + offsetX

		// Check if the ray at py crosses this edge
		if (y1 <= py && y2 > py) || (y2 <= py && y1 > py) {
			// Compute x coordinate of intersection
			t := (py - y1) / (y2 - y1)
			xi := x1 + t*(x2-x1)
			if px < xi {
				crossings++
			}
		}
	}

	return crossings
}

// generateIconARGBAntialiased creates a Font Awesome lock/unlock icon with
// 2x supersampling for smoother edges. Returns ARGB data at 256x256.
func generateIconARGBAntialiased(connected bool) ([]byte, int32, int32) {
	const size = 256
	const supersample = 2
	const hiSize = size * supersample
	data := make([]byte, size*size*4)

	var polygons [][][2]float64
	var r, g, b uint8

	if connected {
		polygons = faLockPolygons
		r, g, b = 255, 255, 255
	} else {
		polygons = faUnlockPolygons
		r, g, b = 140, 140, 140
	}

	padding := float64(hiSize) * 0.08
	available := float64(hiSize) - 2*padding
	vbAspect := 448.0 / 512.0

	var scaleW, scaleH, offsetX, offsetY float64
	if vbAspect < 1.0 {
		scaleH = available
		scaleW = available * vbAspect
		offsetX = padding + (available-scaleW)/2
		offsetY = padding
	} else {
		scaleW = available
		scaleH = available / vbAspect
		offsetX = padding
		offsetY = padding + (available-scaleH)/2
	}

	// Render at high resolution
	hires := make([]bool, hiSize*hiSize)
	for y := 0; y < hiSize; y++ {
		fy := float64(y) + 0.5
		for x := 0; x < hiSize; x++ {
			fx := float64(x) + 0.5
			crossings := 0
			for _, poly := range polygons {
				crossings += countCrossings(poly, fx, fy, scaleW, scaleH, offsetX, offsetY)
			}
			if crossings%2 == 1 {
				hires[y*hiSize+x] = true
			}
		}
	}

	// Downsample to final size
	ss2 := float64(supersample * supersample)
	for y := 0; y < size; y++ {
		for x := 0; x < size; x++ {
			count := 0
			for dy := 0; dy < supersample; dy++ {
				for dx := 0; dx < supersample; dx++ {
					if hires[(y*supersample+dy)*hiSize+(x*supersample+dx)] {
						count++
					}
				}
			}
			if count > 0 {
				alpha := uint8(math.Round(255 * float64(count) / ss2))
				idx := (y*size + x) * 4
				data[idx] = alpha
				data[idx+1] = r
				data[idx+2] = g
				data[idx+3] = b
			}
		}
	}

	return data, int32(size), int32(size)
}
